{{define "testfunction"}}{{$f := .}}

func {{.TestName}}(t *testing.T) {
	tests := []struct { {{if not $f.PrintInputs}}
		name string{{end}}{{if .Receiver}}{{if .Receiver.IsNamed}}
		{{.Receiver.Name}} {{.Receiver.Type}}{{else}}
		{{.Receiver.ShortName}} {{.Receiver.Type}}{{end}}{{end}}{{range $i, $el := .Parameters}}{{if .IsNamed}}
		{{.Name}} {{.Type}}{{else}}
		in{{$i}} {{.Type}}{{end}}{{end}}{{range $i, $el := .Results}}
		want{{if $f.ReturnsMultiple}}{{$i}}{{end}} {{.Type}}{{end}}{{if .ReturnsError}}
		wantErr bool{{end}}
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests { {{if and (not .OnlyReturnsError) (not .OnlyReturnsOneValue) }}
		{{if .Results}}{{template "funcresults" .}} := {{end}}{{template "funccall" .}}{{end}}{{if .ReturnsError}}
		if {{if .OnlyReturnsError}}err := {{template "funccall" .}}; {{end}} (err != nil) != tt.wantErr {
			t.Errorf("{{template "errmsgfunc" $f}} error = %v, wantErr %v", {{if $f.PrintInputs}}{{range $i, $el := $f.Parameters}}{{if .IsNamed}}tt.{{.Name}}, {{else}}tt.in{{$i}}, {{end}}{{end}}{{else}}tt.name, {{end}}err, tt.wantErr){{if .Results}}
			continue{{end}}
		}{{end}}{{range $i, $el := .Results}}{{if .IsBasicType}}
		if {{if $f.OnlyReturnsOneValue}}got := {{template "funccall" $f}}; {{end}} got{{if $f.ReturnsMultiple}}{{$i}}{{end}} != tt.want{{if $f.ReturnsMultiple}}{{$i}}{{end}} { {{else}}
		if {{if $f.OnlyReturnsOneValue}}got := {{template "funccall" $f}}; {{end}} !reflect.DeepEqual(got{{if $f.ReturnsMultiple}}{{$i}}{{end}}, tt.want{{if $f.ReturnsMultiple}}{{$i}}{{end}}) { {{end}}
			t.Errorf("{{template "errmsgfunc" $f}} {{if $f.ReturnsMultiple}}got{{$i}} {{end}}= %v, want %v", {{if $f.PrintInputs}}{{range $i, $el := $f.Parameters}}{{if .IsNamed}}tt.{{.Name}}, {{else}}tt.in{{$i}}, {{end}}{{end}}{{else}}tt.name, {{end}} got{{if $f.ReturnsMultiple}}{{$i}}{{end}}, tt.want{{if $f.ReturnsMultiple}}{{$i}}{{end}})
		}{{end}}
	}
}

{{end}}
