{{define "function"}} {{$f := .}}

func {{.TestName}}(t *testing.T) {
	tests := []struct { {{if not $f.PrintInputs}}
		name string {{end}} {{with .Receiver}}
		{{Receiver .}} {{.Type}} {{end}} {{range $i, $el := .Parameters}}
		{{Param . $i}} {{.Type}} {{end}} {{range $i, $el := .Results}}
		{{Want $i}} {{.Type}} {{end}} {{if .ReturnsError}}
		wantErr bool {{end}}
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests { {{if and (not .OnlyReturnsError) (not .OnlyReturnsOneValue) }}
		{{template "results" $f}} {{template "call" $f}} {{end}} {{if .ReturnsError}}
		if {{if .OnlyReturnsError}} err := {{template "call" $f}}; {{end}} (err != nil) != tt.wantErr {
			t.Errorf("{{template "message" $f}} error = %v, wantErr %v", {{template "inputs" $f}} err, tt.wantErr) {{if .Results}}
			continue {{end}}
		} {{end}} {{range $i, $el := .Results}} {{if .IsBasicType}}
		if {{template "inline" $f}} {{Got $i}} != tt.{{Want $i}} { {{else}}
		if {{template "inline" $f}} !reflect.DeepEqual({{Got $i}}, tt.{{Want $i}}) { {{end}}
			t.Errorf("{{template "message" $f}} {{if $f.ReturnsMultiple}}{{Got $i}} {{end}}= %v, want %v", {{template "inputs" $f}} {{Got $i}}, tt.{{Want $i}})
		} {{end}}
	}
}

{{end}}
